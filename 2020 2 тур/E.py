# Функця для знаходження (a**n)%p за O(log)
def power_mod(a, n, p):

    res = 1

    # a повинно бути менше за p
    a = a % p

    while n > 0:

        # якщо n непарне то, множимо a на результат
        if n % 2:
            res = (res * a) % p
            n = n - 1
        else:
            # якщо n парне то ділимо на 2
            a = (a ** 2) % p
            n = n // 2

    return res % p

# Швидкий ймовірнісний тест числа на простоту. При декількох ітераціях (13) ймовірність правильності теста 99.999999%


def isPrime(n, k=13):

    # Винятки для 1,2,3,4
    if n == 1 or n == 4:
        return False
    elif n == 2 or n == 3:
        return True

    else:
        for i in range(k):

            # Вибираємо випадкове число з проміжку [2..n-2]
            a = random.randint(2, n - 2)

            # Застосовуємо малу теорему Ферма
            # https://uk.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BB%D0%B0_%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%A4%D0%B5%D1%80%D0%BC%D0%B0
            if power_mod(a, n - 1, n) != 1:
                return False

    return True

 # ================================================================================
# всі прості числа крім 2 непарні, тому як суму двох простих чисел можна Х подати число тільки
# якщо Х - парне, або якщо один доданок 2, а інший (Х-2) - теж просте число


a, b = list(map(int, input().split()))

k = 0
# фікс бага для тесту коли a == 2, тому що 2 і 3 не можуть бути представлені сумою простих
for number in range(max(a, 4), b+1):
    if number % 2 == 0 or isPrime(number-2):
        k += 1
print(k)
